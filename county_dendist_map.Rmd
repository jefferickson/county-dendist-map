---
title: "County Density/Distance Map"
author: "Jeff Erickson"
date: "Tuesday, June 17, 2014"
output: html_document
---

### LOAD REQUIRED LIBRARIES

```{r}
library(rgdal)
library(ggmap)
library(ggplot2)
library(rgeos)
```

### IMPORT DATA

```{r}
#County Shapes from US Census
county.shapes <- readOGR(dsn="datasets", "gz_2010_us_050_00_500k")

#County population centroids from US Census
county.pop.center <- read.csv("datasets/CenPop2010_Mean_CO.txt", header=TRUE)

#County population density information from US Census
county.density <- read.csv("datasets/DEC_10_SF1_GCTPH1.CY07_with_ann.csv", header=TRUE, as.is=TRUE)

#Major city (primary statistical areas) from gen.maj.city.long.lat.Rmd
maj.city.long.lat <- read.csv("datasets/maj.city.long.lat.csv", header=TRUE)
```

### HELPER FUNCTIONS

```{r}
deg.2.rad <- function(x) { #Convert vector from degrees to radians
  return(sapply(x, function(deg) {
    return(deg * (pi/180))
  }))
}

euclid.dist <- function(x) { #Simple Euclidean distance
  #arg: c(lat1, long1, lat2, long2)
  return(sqrt((x[1]-x[3])^2 + (x[2]-x[4])^2))
}

haversine.dist <- function(x) { 
  #Implementation of the haversine formula
  #http://en.wikipedia.org/wiki/Haversine_formula
  #http://stackoverflow.com/questions/27928/how-do-i-calculate-distance-between-two-latitude-longitude-points
  #arg: c(lat1, long1, lat2, long2)
  coords <- deg.2.rad(x)
  earth.r <- 6371 #earth radius in km
  d.long.rad <- coords[2] - coords[4]
  d.lat.rad <- coords[1] - coords[3]

  a <- sin(d.lat.rad/2)^2 + cos(coords[1]) * cos(coords[3]) * sin(d.long.rad/2)^2
  c <- 2 * atan2(sqrt(a), sqrt(1 - a))
  d <- earth.r * c
  return(d)
}

google.driving.dist <- function(x) {
  #Get Google driving distance
  #http://stackoverflow.com/questions/16863018/getting-driving-distance-between-two-points-lat-lon-using-r-and-google-map-ap
  #Has the following limitations:
  #100 elements per query.
  #100 elements per 10 seconds.
  #2500 elements per 24 hour period.
  #arg: c(lat1, long1, lat2, long2)
  library(XML)
  library(RCurl)
  origin <- paste(x[1], x[2], sep=",")
  dest <- paste(x[3], x[4], sep=",")
  url <- paste0('http://maps.googleapis.com/maps/api/distancematrix/xml?origins=', origin, '&destinations=', dest, '&mode=driving&sensor=false')
  xml.resp <- xmlParse(getURL(url))
  d.lab <- xmlValue(xmlChildren(xpathApply(xml.resp, "//distance")[[1]])$text)
  d <- as.numeric(sub(" km", "", d.lab))
  return(d)
}

z.score <- function(x) { #Calc z-scores
  #arg: a vector of values to z-score
  return((x - mean(x)) / sd(x))
}

link.func.unwgted.avg <- function(x, y) { #Unweighted average of each argument (row-by-row), then scaled to [0,1]
  #arg: two vectors of numeric to be averaged and scaled
  index.unscaled <- apply(data.frame(x, y), 1, function(x) { return(mean(x)) })
  index.shifted <- index.unscaled - min(index.unscaled)
  index.scaled <- index.shifted / max(index.shifted)
  return(index.scaled)
}
```

### DATA TRANSFORMATIONS

```{r}
#We only want counties, not census tracts
county.density <- county.density[which(county.density$GEO.id2 == county.density$GCT_STUB.target.geo.id2), ]

#Create key that is used to merge
county.pop.center$GEO_ID <- paste("0500000US", formatC(county.pop.center$STATEFP, width=2, flag="0"), formatC(county.pop.center$COUNTYFP, width=3, flag="0"), sep="")

#For now, only the lower 48 states
county.density <- county.density[which(! (substr(county.density$GEO.id, 10, 11) %in% c("02", "52", "15", "72"))), ] #remove AK, HI, PR (2 codes)
county.pop.center <- county.pop.center[which(! (substr(county.pop.center$GEO_ID, 10, 11) %in% c("02", "52", "15", "72"))), ] #remove AK, HI, PR (2 codes)

#Convert field(s) to numeric
county.density$SUBHD0401 <- as.numeric(county.density$SUBHD0401)
```

### CALCULATE DISTANCES AND DEN-DIST INDEX

```{r}
#Create a list of all unique combinations of counties and the major cities
county.city.list.long <- merge(county.pop.center$GEO_ID, maj.city.long.lat$id, all.x=TRUE, all.y=TRUE)
names(county.city.list.long) <- c("county.geo.id", "city.id")

#For each combination, calculate the distance
county.city.list.long$dist <- apply(county.city.list.long[c("county.geo.id", "city.id")], 1, function(x) {
  dist <- haversine.dist(as.numeric(
    c(
      county.pop.center[which(county.pop.center$GEO_ID == x[1]), c("LATITUDE", "LONGITUDE")],
      maj.city.long.lat[which(maj.city.long.lat$id == x[2]), c("lat", "long")]
    )
  ))
  return(dist)
})

#Merge on the county densities
county.city.list.long <- merge(county.city.list.long, county.density[c("GEO.id", "SUBHD0401")], by.x="county.geo.id", by.y="GEO.id", all.x=TRUE)

#Dedupe based on shortest distance
county.city.list.shortest <- do.call(rbind, lapply(split(county.city.list.long, county.city.list.long$county.geo.id), function(x) {
  return(x[which.min(x$dist), ])
}))

#transform density with log
county.city.list.shortest$den.log <- log(county.city.list.shortest$SUBHD0401)

#let's "flip" the distances so that high values of both density and "distance" mean more urban than rural
county.city.list.shortest$dist.flip <- -(county.city.list.shortest$dist - (max(county.city.list.shortest$dist) + 1))

#z-score both transform of density and distance-flip
county.city.list.shortest$den.log.z <- z.score(county.city.list.shortest$den.log)
county.city.list.shortest$dist.flip.z <- z.score(county.city.list.shortest$dist.flip)

#create the den-dist index
county.city.list.shortest$den.dist.index <- link.func.unwgted.avg(county.city.list.shortest$den.log.z, county.city.list.shortest$dist.flip.z)
```

### MERGE DEN-DIST DATA WITH MAPPING INFO

```{r}
#Fortify the shapefile and use the FIPS codes as id
county.shapes.f <- fortify(county.shapes, region="GEO_ID")

#Merge on our demo data
county.shapes.f.dendist <- merge(county.shapes.f, county.city.list.shortest, by.x="id", by.y="county.geo.id")
```

### MAP IT!

```{r}
ggplot(county.shapes.f.dendist[order(county.shapes.f.dendist$order), ], aes(x=long, y=lat, group=group)) + #careful: order matters here
  geom_polygon(aes(fill=den.dist.index), colour="black") +
  coord_equal() +
  scale_fill_continuous(low="white", high="blue")
```